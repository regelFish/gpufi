diff --git a/injector/Makefile b/injector/Makefile
index 5edba0b..cb1c603 100644
--- a/injector/Makefile
+++ b/injector/Makefile
@@ -17,7 +17,7 @@ DUMMY=0
 
 SOURCES=$(wildcard *.cu)
 OBJECTS=$(SOURCES:.cu=.o)
-ARCH=35
+ARCH=75
 
 NVBIT_TOOL=injector.so
 
diff --git a/profiler/Makefile b/profiler/Makefile
index a542a7f..de51579 100644
--- a/profiler/Makefile
+++ b/profiler/Makefile
@@ -18,7 +18,7 @@ NVCC_PATH=-L $(subst bin/nvcc,lib64,$(shell which nvcc | tr -s /))
 
 SOURCES=$(wildcard *.cu)
 OBJECTS=$(SOURCES:.cu=.o)
-ARCH=35
+ARCH=75
 
 # Profiling is often slow. Using an approximate profile can speed it up by
 # orders of magnitude.  Set FAST_APPROXIMATE_PROFILE to SKIP_PROFILED_KERNELS
diff --git a/profiler/inject_funcs.cu b/profiler/inject_funcs.cu
index 5778300..5919af9 100644
--- a/profiler/inject_funcs.cu
+++ b/profiler/inject_funcs.cu
@@ -27,12 +27,12 @@ extern "C" __device__ __noinline__ void count_instrs(uint64_t pcounters, int ind
 	// Optimization: Instead of all the threads in a warp performing atomicAdd,
 	// let's count the number of active threads with predicate=1 in a warp and let just one thread
 	// (leader) in the warp perform the atomicAdd
-	const int active_mask = ballot(1);
+	const int active_mask = __ballot_sync(0xFFFFFFFF, 1);
 	const int leader = __ffs(active_mask) - 1;
 	const int laneid = get_laneid();
 
 	// compute the predicate mask 
-	const int predicate_mask = ballot(predicate);
+	const int predicate_mask = __ballot_sync(0xFFFFFFFF, predicate);
 	const int num_threads = __popc(predicate_mask);
 
 	if (laneid == leader) { // Am I the leader thread
diff --git a/test-apps/simple_add/Makefile b/test-apps/simple_add/Makefile
index e7299a4..1abb36b 100644
--- a/test-apps/simple_add/Makefile
+++ b/test-apps/simple_add/Makefile
@@ -2,7 +2,7 @@ TARGET = simple_add
 
 # CUDA
 NVCC = `which nvcc`
-ARCH=35
+ARCH=75
 
 all: clean $(TARGET) 
 
diff --git a/test-apps/simple_add/simple_add.cu b/test-apps/simple_add/simple_add.cu
index 5542b05..ec8759c 100644
--- a/test-apps/simple_add/simple_add.cu
+++ b/test-apps/simple_add/simple_add.cu
@@ -78,12 +78,21 @@ int main(int argc, char *argv[])
 
 	//Set the device
 	int device = 0;
-	cudaSetDevice(device);
+	cudaError_t err = cudaSetDevice(device);
+	if (err != cudaSuccess) {
+		printf("Error setting device: %s\n", cudaGetErrorString(err));
+		return 1;
+	}
+	
 	cudaDeviceProp cudaDevicePropForChoosing;
-	cudaGetDeviceProperties(&cudaDevicePropForChoosing, device);
+	err = cudaGetDeviceProperties(&cudaDevicePropForChoosing, device);
+	if (err != cudaSuccess) {
+		printf("Error getting device properties: %s\n", cudaGetErrorString(err));
+		return 1;
+	}
 
 	printf("Device %d (%s) is being used\n", device, cudaDevicePropForChoosing.name);
-	printf("memory: %.4f GB %s %d SMs x%d\n", cudaDevicePropForChoosing.totalGlobalMem/(1024.f*1024.f*1024.f), (cudaDevicePropForChoosing.ECCEnabled)?"ECC on":"ECC off", cudaDevicePropForChoosing.multiProcessorCount, cudaDevicePropForChoosing.clockRate );
+	printf("memory: %.4f GB %s %d SMs\n", cudaDevicePropForChoosing.totalGlobalMem/(1024.f*1024.f*1024.f), (cudaDevicePropForChoosing.ECCEnabled)?"ECC on":"ECC off", cudaDevicePropForChoosing.multiProcessorCount);
 
 	int nreps = DEFAULT_NREPS;
 	int ctas = DEFAULT_CTAS;
